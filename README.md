# openob-gui

OpenOB-gui is a simple graphical user interface for OpenOB (Open Outside Broadcast), a simple Python/GStreamer based application which implements a highly configurable RTP-based audio link system.
This application is designed to run on Raspberry with Raspbian 8 (Debian Jessie) and is coded in PHP and requires some system permissions. (To modify the interfaces or restart)

# Installation

Install Raspbian Jessie Lite on a SD card: https://www.raspberrypi.org/downloads/raspbian/ (**Do not install PIXEL !**)

Install OpenOB on your Debian system: http://jamesharrison.github.io/openob/tutorial.html#openob-system-basics

** In case of apt problems, remove python-argparse and gstreamer0.10-ffmpeg, these packets are apparently not required. **

# Use the good user

Do not take the bad habit of being permanently connected to root!
Whether it's a raspberry pi test at $ 65 or a supermicro production server has $ 2,000!

**To do the installation, connect with the user "pi" to your raspberry.**

# Install a nginx

Nginx is available as a package for Debian Jessie which we can install as follows:
	
	sudo apt-get -y install nginx
	
# Install PHP-FPM

We can make PHP5 work in nginx through PHP-FPM (PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI implementation
with some additional features useful for sites of any size, especially busier sites) which we install as follows:
	
	sudo apt-get -y install php5-fpm

# Configuring nginx

The nginx configuration is in /etc/nginx/nginx.conf which we open now:

	sudo nano /etc/nginx/nginx.conf
	
The configuration is easy to understand (you can learn more about it here: http://wiki.nginx.org/NginxFullExample and here: http://wiki.nginx.org/NginxFullExample2)


First set the keepalive_timeout to a reasonable value like 2 seconds:

	[...]
    	keepalive_timeout   2;
	[...]

The virtual hosts are defined in server {} containers. The default vhost is defined in the file /etc/nginx/sites-available/default - let's modify it as follows:

	sudo nano /etc/nginx/sites-available/default

and modify:

	[...]
	server {
	 listen 80 default_server;
	 listen [::]:80 default_server;

	 # SSL configuration
	 #
	 # listen 443 ssl default_server;
	 # listen [::]:443 ssl default_server;
	 #
	 # Self signed certs generated by the ssl-cert package
	 # Don't use them in a production server!
	 #
	 # include snippets/snakeoil.conf;

	 root /var/www/html;

	 # Add index.php to the list if you are using PHP
	 index index.html index.htm index.nginx-debian.html index.php;

	 server_name _;

	 location / {
	 # First attempt to serve request as file, then
	 # as directory, then fall back to displaying a 404.
	 try_files $uri $uri/ =404;
	 }

	 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
	 #
	 location ~ \.php$ {
	 include snippets/fastcgi-php.conf;
 
	 # # With php5-cgi alone:
	 # fastcgi_pass 127.0.0.1:9000;
	 # With php5-fpm:
	 fastcgi_pass unix:/var/run/php5-fpm.sock;
	 }

	 # deny access to .htaccess files, if Apache's document root
	 # concurs with nginx's one
	 #
	 location ~ /\.ht {
	 deny all;
	 }
	}
	[...]
	
server_name _; makes this a default catchall vhost (of course, you can as well specify a hostname here like www.example.com).

I've added index.php to the index line. root /var/www/html; means that the document root is the directory /var/www/html.

The important part for PHP is the location ~ \.php$ {} stanza. Uncomment it like shown above to enable it.

# Configure PHP

	sudo nano /etc/php5/fpm/php.ini

... and set cgi.fix_pathinfo=0:

	[...]
	; cgi.fix_pathinfo provides *real* PATH_INFO/PATH_TRANSLATED support for CGI.  PHP's
	; previous behaviour was to set PATH_TRANSLATED to SCRIPT_FILENAME, and to not grok
	; what PATH_INFO is.  For more information on PATH_INFO, see the cgi specs.  Setting
	; this to 1 will cause PHP CGI to fix its paths to conform to the spec.  A setting
	; of zero causes PHP to behave as before.  Default is 1.  You should fix your scripts
	; to use SCRIPT_FILENAME rather than PATH_TRANSLATED.
	; http://php.net/cgi.fix-pathinfo
	cgi.fix_pathinfo=0
	[...]

# Clone the project

	cd /home/pi
	git clone https://github.com/mickaelmonsieur/openob-gui.git
	
# Adapt nginx/PHP

sudo nano /etc/nginx/sites-available/default
	
	root /home/pi/openob-gui/html;
	error_page 500 502 503 504 /custom_50x.html;

sudo nano /etc/php5/fpm/pool.d/www.conf

	user = pi
	group = pi

Restart services:

	sudo /etc/init.d/nginx restart
	sudo /etc/init.d/php5-fpm restart

# Configure sudo permissions

sudo nano /etc/sudoers

	pi ALL=(ALL) NOPASSWD:/sbin/shutdown

Add the user "pi" to netdev group for editing dhcp client

	sudo usermod -a -G netdev pi

# Add autostart support

sudo nano /etc/rc.local

	su - pi -c /home/pi/openob-gui/autostart.sh
	
# Set application mode

Specify if your raspberry is a outstreamer (player) or a instreamer (encoder)
per default, the config file is a instreamer.
simply comment/uncomment the correct line.

nano /home/pi/openob-gui/html/config.php

	//define('MODE', 'outstreamer');
	define('MODE', 'instreamer');

# Test-it!

Go to: http://raspberry_ip:80/

# Community 

Developpers, do not hesitate to suggest your pull requests! :)

# Professional support

I am available in consulting for the radios that would be interested to deploy the solution.
(To do this through my personal website : http://www.mickael.be)

# Security

The GUI follows the same logic as OpenOB, ie do not expose the player/encoder on the Internet, nothing is protected. 
Neither the openOB-GUI interface, although you can add Nginx authentication, nor the ports of redis and OpenOB.

To connect 2 remote OpenOB over the Internet, it is strongly recommended that you set up a VPN or MPLS tunnel.

# Licence

GNU Affero General Public License v3.0

https://www.gnu.org/licenses/agpl-3.0.en.html

